# 5장 올바른 데이터 읽기

데이터 통신에 관한 내용(내부, 외부) 



내용

- 콜백을 통한 **부모-자식** 통신
- 공통 부모를 통한 **형제간** 통신
- 상위 컨테이너 만들어(재사용성 위해) api호출하여 데이터 읽고 컴포넌트에 적용
- react-refetch 라이브러리 활용



## 데이터 흐름, 공유

리액트는 데이터가 루트에서 리프로 이동하는 패턴 적용함. - **단방향 데이터 흐름 (Undirectional Data Flow)**

-> 장점 : 컴포넌트의 동작과 관계를 간소화, 예측 가능한 코드, 쉬운 유지보수



<u>부모 -> 자식</u> : 프로퍼티를 통한 데이터 전달

그렇다면,

<u>자식 -> 부모 데이터 푸시or 이벤트 트리거</u> : ?

<u>형제간 데이터 공유</u> : ?



*기존 코드*

```react
class Counter extends React.Component{
    constructor(props){
        super(props);

        this.state={
            counter:0,
        }

        this.handleDecrement = this.handleDecrement.bind(this);
        this.hanldeIncrement = this. hanldeIncrement.bind(this);
    }

    handleDecrement(){
        this.setState({
            counter: this.state.counter - 1,
        })
    }

    handleIncrement(){
        this.setState({
            counter: this.state.counter + 1,
        })
    }

    render(){
        return(
            <div>
                <h1>{this.state.counter}</h1>
                <button onClick={this.hanldeIncrement}>+</button>
                <button onClick={this.handleDecrement}>-</button>
            </div>
        )
    }
}
```

- 상태에 카운터값 저장
- 데이터 표시
- 증가, 감소 논리 포함 - handleInCrement, handleDecrement



우선, 위에서 증가, 감소 동작을 **유지관리, 재사용성**을 위해 분리시킨다. 

1. 자식(Buttons) -> 부모(Counter)

   ```react
   //증가, 감소 버튼 + 프로퍼티 통한 콜백함수 호출
   class Buttons extends React.Component{
       render(){
           return(
               <div>
                   <button onClick={this.props.onDecrement}>-</button>
                   <button onClick={this.props.onIncrement}>+</button>
               </div>
           )
       }
   }

   Buttons.propTypes={
       onDecrement: React.PropTypes.func,
       onIncrement: React.PropTypes.func,
   }
   ```

   Counter의 render 부분에 Buttons컴포넌트를 적용할 수 있다.

   ```react
   render(){
           return(
               <div>
                   <h1>{this.state.counter}</h1>
                   <Buttons onInCrement={this.handleIncrement}
                            onDeCrement={this.handleDecrement}
                            />
               </div>
           )
   }
   ```

   이렇게 프로퍼티를 통해 **콜백**을 자식 컴포넌트에 전달하고, 자식에서는 내부함수가 아닌 전달받은 **콜백을 사용해** 부모에 **데이터전달 혹은 이벤트 트리거**시키고, 나머지 논리를 부모에서 구현하게끔 할 수 있다

   - 단순화된 버튼, 부모에게 알리는 역할만 함
   - Buttons를 재사용할 수 있게됨
     ​

   다른 예시)

   부모 컴포넌트에서 **changeState 콜백함수를 자식에게 프로퍼티로 전달**하면, 자식컴포넌트에서는 해당 콜백함수를 가지고 **부모에게 특정 값을 전달해주는 콜백함수를 버튼 이벤트 핸들러에 할당**한다. 그럼 버튼 클릭시 호출되고 부모의 data 값에 'inputValue'를 전달한다. 

   ```react
   class ParentComponent extends React.Component{
       state: { data: '' }

       changeState = (inputValue) => {
           this.setState({data: inputValue});
       }

       render() {
            return (
                   <div>
                       <ChildeComponent changeParentState={this.changeState}/> 
                   </div>
           )
        }
   }

   class ChildComponent extends React.Component {

       changeValue = () => {
           var inputValue = "inputValue";
           this.props.changeParentState(inputValue);            
       }

       render() {
           return (
               <div >
                   <button onClick={this.changeValue}/>
               </div>            
           );
       }
   }

   ```

   ​

2. 형제간 통신 - Display, Buttons

   ```react
   //지금은 단순하지만, 값에 따라 다른 색으로 표시하는 것 같이 추가적인 논리를 적용할 수 있다.
   class Display extends React.Component{
       render(){
           return(
               <h1>{this.props.counter}</h1>
           )
       }
   }

   Display.propType = {
       counter : React.PropType.number
   }
   ```

   Counter의 render부분에 Display 컴포넌트 적용할 수 있다.

   ```react
   render(){
           return(
               <div>
                   <Display counter={this.state.number}/>
                   <Buttons onInCrement={this.handleIncrement}
                            onDeCrement={this.handleDecrement}
                            />
               </div>
           )
   }
   ```

   위 Display, Buttons 두 형제 컴포넌들은  **Counter라는 공통 부모**를 통해 통신하게 된다.

   **Buttons 클릭 -> 부모로 알림 -> 부모에서 논리 적용한 업데이트 -> Display로 값 전달**

   이 패턴이 리액트에서 일반적인 패턴이다.

   <u>**데이터는 항상 부모에서 자식으로 가지만, 자식이 부모에 알림 보내고 새로운 정보로 트리를 다시 렌더링하게 만들 수 있다.**</u>

   **<u>공통 부모를 두고 상태가 업데이트 될 때마다 프로퍼티 통해 전달</u>**



## 데이터 읽기

여기서 데이터 읽기란 - 네트워크 요청 후 fetch / ajax 처리

<u>**데이터 가져오는 방법 + 해당 논리의 위치 선정**</u>에 대한 내용

XHR -> **fetch 함수**로 대체하여 요청 수행

*cf. 크롬, 파이어폭스는 지원함. 이외 브라우저는 fetch polyfill을 사용해야함.*



**내부 상태 저장**하고 **수명주기 메소드**를 사용



<u>**componentWillMount**와 **componentDidMount**에 데이터읽기를 넣을 수 있다.</u>

1. componentWillMount - 컴포넌트가 렌더링되기 전에 호출

   서버 측, 클라이언트 측 렌더링에서 모두 호출됨

   서버에서 렌더링 될 때 비동기 api 호출시 문제 생길 수 있으니 주의해야함

   > By the time `componentDidMount` is called, the component has been rendered once.
   >
   > In practice, `componentDidMount` is **the best place to put calls to fetch data**, for two reasons:
   >
   > 1. Using **Did**Mount makes it clear that **data won’t be loaded until *after* the initial render**. This reminds you to set up initial `state` properly, so you don’t end up with [undefined state that causes errors](https://daveceddia.com/watch-out-for-undefined-state).
   > 2. If you ever need to render your app on the server (isomorphic), `componentWillMount` will actually **be called *twice*** – **once on the server, and again on the client** – which is probably not what you want. Putting the data loading code in **`componentDidMount` will ensure that data is only fetched from the client.**

   ​

2. componentDidMount - 컴포넌트가 마운트된 후 곧바로 호출 <- react manual에서 권장

   ```react
   class Gists extends React.Component{
       constructor(props){
           super(props);

           //생성자에서 상태 초기화
           this.state={
               gists: []
           }
       }

       componentDidMount(){
           //fetch 사용해 데이터 읽어옴
           //username 유저의 gist 목록 반환
           fetch('https://api.github.com/users/:username/gists')
           .then(response => response.json())
           .then(gists => this.setState({
                   gists
           }))
       }
       ...
   }
   ```

   - fetch함수는 **Promise를 반환**

   - then 메소드 사용해 응답에서 **json 가져옴**

   - 해당 json 정보를 컴포넌트의 **내부 상태에 저장 후 사용**

     ```react
     //사용
     render(){
             return(
                 <ul>
                     //json안의 데이터 꺼내어 리스트로 마크업
                     {this.state.gists.map(item=>(
                         <li key={item.id}>{item.description}</li>
                     ))}
                 </ul>
             )
         }
     ```

     cf. li의 key 프로퍼티

     > **Keys help React identify which items have changed, are added, or are** 
     > **removed**. Keys should be given to the elements inside the array to **give** 
     > **the elements a stable identity**
     >
     > **We don’t recommend using indexes for keys** if the order of items may 
     > change. This can negatively impact performance and may cause issues with
     >  component state.

     참고 :  [in-depth explanation on the negative impacts of using an index as a key](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318)

   ​

   <u>구조개선</u>

   재사용성 위해 **상위 컴포넌트를 작성**한다.

   ```react
   //url 받고 실제 컴포넌트(자식)를 매개변수로 받아 새로운 컴포넌트를 반환하는 구조
   const withData = url => Component => (
       class extends React.Component {
           ...
       }
   )
   ```

   범용 컴포넌트이므로 data로

   ```react
   class extends React.Component {
     
         constructor(props) {
           super(props)
     
           this.state = { data: [] }
         }
         ...
       }
   ```

   위에서 했던 대로 **componentDidMount에 fetch 호출**

   ```react
   componentDidMount() {
       	//상위 컴포넌트에서 받은 url 설정
           fetch(url)
            .then(response => response.json())
            .then(data => this.setState({
               		data 
            }))
    }
   ```

   그리고 **실제 활용될 자식 컴포넌트(Component)에 전달**한다.

   ```react
   //프로퍼티 및 상태 전개한 컴포넌트 렌더링
   render() {
           return <Component {...this.props} {...this.state} />
         }
   ```

   ​
   이러면 api호출을 여러 곳에서 재활용할 수 있게 만들 수 있다. -> <u>**상위컴포넌트(withData)로 다른 컴포넌트를 래핑하면 설정한 url에서 받은 데이터를 해당 컴포넌트로 전달한다.**</u>

   예시)

   ```react
   class Gists extends React.Component{
       propTypes:{
           data : React.PropTyeps.array
       }
       
       render(){
           return(
               <ul>
                   {this.props.data.map(item=>(
                       <li key={item.id}>{item.description}</li>
                   ))}
               </ul>
           )
       }
   }
   ```

   상위컴포넌트 사용 : url 및 컴포넌트 래핑 -> 새로운 컴포넌트 생성

   ```react
   const ListWithGists = withData('https://api.github.com/users/lee/gists')(Gists)
   ```

   ​

   하지만 지금은 정적 url만 가능하므로 url을 동적으로 받는 코드로 변경 - 매개변수나 props로 지정

   componentDidMount에서 api 호출전에 처리해준다.

   ```react
   componentDidMount() {
       	//url을 문자열, 함수 두가지로 받는 케이스
           const endpoint = typeof url === 'function' ? url(this.props) : url
     
           fetch(endpoint)
             .then(response => response.json())
             .then(data => this.setState({ data }))
   }

   ...
   //url과 컴포넌트를 전달
   const ListWithGists = withData(props => 'https://api.github.com/users/${props.username}/gists')(Gists)

   ....
   //ListWithGists 컴포넌트 사용시 username으로 프로퍼티 전달하면 됨
   <ListWithGists username="lee"/>
   ```

   ​

## react-refetch

위에 더해서 추가적인 기능 + 지연로드(componentDidMount 사용 x) 필요할때 쓸 수 있는 유용한 라이브러리

```
$ npm install react-refetch --save
```

```react
//connect 함수를 가져온다.
import { connect } from 'react-refetch'
```



<u>기본 작성법</u>

```react

const ListWithGists = connect(({ username }) => ({
  data: 'https://api.github.com/users/${username}/gists',
}))(Gists)

```

1. connect함수는 **순수함수를 매개변수**로 받는다. 

2. 그 함수는 매개변수로 받은 프로퍼티(username)을 사용해 동적 url 생성한 후 **{키(data) : 값(url)}인 객체를 반환**하게 된다. 

3. 반환받은 객체를 이용해 connect함수는 사용될 컴포넌트(Gists)를 받아 **지정된 키(data)와 동일한 이름의 프로퍼티(data)에 값을 주입**하게 된다.

4. data프로퍼티에 주입된 값 = **PromiseState** 객체

   *cf. Promise와 유사하게 **pending, fulfilled, rejected의 상태**를 가지게 되며 각각 요청 중, 수행 완료, 오류 발생 시 에 쓰일 수 있다.*

5. 요청이 수행 완료(data.fulfilled===true)되면 **value 프로퍼티**를 사용해 데이터에 접근가능하다.

```react
const Gists = ({ data }) => (
  //렌더링 후, 요청이 수행되었는지 검사하고 성공 시 리스트 표시
  data.fulfilled && (
    <ul>
      {data.value.map(item => (
        <li key={item.id}>{item.description}</li>
      ))}
    </ul>
  )
)

Gists.propTypes = {
    data : React.PropTypes.object // PromiseState이므로 변경
}
```



<u>추가기능</u>

gist에 있는 특정 게시물에 star 추가하는 코드

```react
const token = 'access_token=123'//액션에 필요한 인증 토큰

const Gist = ({ description, star }) => (
  <li>
    {description}
    <button onClick={star}>+1</button>
  </li>
)

Gist.propTypes = {
  description: React.PropTypes.string,
  star: React.PropTypes.func,
}

const GistWithStar = connect(({ id }) => ({
  //함수가 전달
  star: () => ({
    starResponse: {
      url: `https://api.github.com/gists/${id}/star?${token}`,
      method: 'PUT',
    },
  }),
}))(Gist)
```

connect함수에서 

1. 요청 **키의 값이 문자열**이면 프로퍼티가 사용 가능해지는 **즉시 데이터를 읽는다.**

2. 요청 **키의 값이 함수**이면 **<u>해당 함수가 컴포넌트로 전달, 지연 호출</u>**할 수 있다. - star

   -> 버튼 클릭 이벤트 발생 시 함수 트리거

   ​






















----



데이터의 흐름 & 부모-자식, 형제간 컴포넌트들 끼리의 데이터 통신 및 공유하는 방법을 이해해야함.

1. 기본 컴포넌트 -> 상위 컴포넌트 이용 -> 구조화
2. 데이터 읽기의 실용적 예제
3. 리액트 리페치(react-refetch) 라이브러리 활용한 데이터 읽기

